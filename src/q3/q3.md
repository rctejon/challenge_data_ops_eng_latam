# Q3: Top 10 usuarios m치s influyentes

## Objetivo
Obtener los top 10 usuarios m치s influyentes en funci칩n del n칰mero de menciones (@) que reciben en los tweets. Retornar el username y su conteo de menciones.

## Enfoque

### Optimizaci칩n por tiempo (q3_time.py)

**Estrategia**: Carga completa en memoria usando Polars con procesamiento vectorizado.

**Caracter칤sticas**:
- Carga completa del dataset en memoria (scan_ndjson + collect)
- Extracci칩n de menciones desde el campo estructurado `mentionedUsers`
- Operaciones de explode + struct.field para extracci칩n eficiente del username
- Group_by para conteo eficiente de menciones por usuario
- Garbage collection estrat칠gico para liberar memoria intermedia
- Trade-off: velocidad m치xima a costa de mayor uso de RAM

**Complejidad**:
- Tiempo: O(n) para procesamiento + O(k log k) para sort (k = usuarios 칰nicos)
- Espacio: O(n) por DataFrame en memoria + O(m) por menciones (m = total menciones)

#### Ejecuci칩n

**Prerequisitos**:
Asegurarse que el dataset existe en `data/raw/farmers-protest-tweets-2021-2-4.json`. Si no existe, descargar primero:
```bash
python src/dataset/download_dataset.py
```

**Comando de ejecuci칩n**:
```bash
python src/q3/q3_time_impl.py
```

**Salida esperada**:
- Muestra los top 10 usuarios m치s influyentes con su conteo de menciones
- Ejecuta profiling de tiempo con cProfile
- Ejecuta profiling de memoria con memray (si est치 instalado)

**Archivos generados**:
- `q3_time_polars.prof` - Profiling de tiempo (cProfile)
- `q3_time_polars_mem.bin` - Profiling de memoria (memray)

#### An치lisis de profiling

**Analizar profiling de tiempo**:
```bash
python -m pstats q3_time_polars.prof
```

Comandos 칰tiles dentro de pstats:
```
stats 10        # Top 10 funciones por tiempo total
sort cumulative # Ordenar por tiempo acumulativo
sort time       # Ordenar por tiempo propio
```

**Analizar profiling de memoria**:
```bash
# Ver estad칤sticas generales
memray stats q3_time_polars_mem.bin
```

**Nota**: Si memray no est치 instalado, se puede instalar con:
```bash
pip install memray
```

### Optimizaci칩n por memoria (q3_memory.py)

**Estrategia**: Procesamiento con lazy evaluation y materializaci칩n m칤nima.

**Caracter칤sticas**:
- Lazy evaluation completa sin collect() intermedio
- Solo materializa el resultado final (top 10)
- Streaming aggregations de Polars
- Trade-off: menor consumo de memoria a costa de mayor tiempo de ejecuci칩n (si aplica)

**Complejidad**:
- Tiempo: O(n) para procesamiento streaming
- Espacio: O(1) - solo materializa el resultado final peque침o (top 10 usuarios)

#### Ejecuci칩n

**Prerequisitos**:
Asegurarse que el dataset existe en `data/raw/farmers-protest-tweets-2021-2-4.json`. Si no existe, descargar primero:
```bash
python src/dataset/download_dataset.py
```

**Comando de ejecuci칩n**:
```bash
python src/q3/q3_memory_impl.py
```

**Salida esperada**:
- Muestra los top 10 usuarios m치s influyentes con su conteo de menciones
- Ejecuta profiling de tiempo con cProfile
- Ejecuta profiling de memoria con memray (si est치 instalado)

**Archivos generados**:
- `q3_memory_polars.prof` - Profiling de tiempo (cProfile)
- `q3_memory_polars_mem.bin` - Profiling de memoria (memray)

#### An치lisis de profiling

**Analizar profiling de tiempo**:
```bash
python -m pstats q3_memory_polars.prof
```

Comandos 칰tiles dentro de pstats:
```
stats 10        # Top 10 funciones por tiempo total
sort cumulative # Ordenar por tiempo acumulativo
sort time       # Ordenar por tiempo propio
```

**Analizar profiling de memoria**:
```bash
# Ver estad칤sticas generales
memray stats q3_memory_polars_mem.bin
```

**Nota**: Si memray no est치 instalado, se puede instalar con:
```bash
pip install memray
```

---

## Resumen de Resultados y Conclusiones (TIME vs MEMORY)

Para Q3 se implementaron y perfilaron dos enfoques con **Polars**, optimizados respectivamente por **tiempo** y por **memoria**. Ambos producen resultados **id칠nticos y deterministas**, por lo que la comparaci칩n se centra en performance y consumo de recursos.

---

## 1. Resultados Clave

| Enfoque | Tiempo ejecuci칩n (script) | Tiempo (cProfile) | Peak RSS (memray) | Caracter칤stica dominante |
|-------|----------------------------|-------------------|-------------------|--------------------------|
| **Polars TIME** | ~0.60 s | ~0.285 s | ~429 MB | Velocidad m치xima |
| **Polars MEMORY** | ~0.63 s | ~0.256 s | ~427 MB | Menor materializaci칩n |

- Ambos enfoques usan el mismo motor (Polars + Arrow + lazy execution).
- En este caso, TIME y MEMORY terminan siendo **muy similares** en tiempo y memoria.

---

## 2. Insights de Performance

### Polars TIME
- El tiempo est치 dominado por `LazyFrame.collect()`, que concentra pr치cticamente todo el costo medido por cProfile (0.271s de 0.285s).
- Parsing y materializaci칩n del NDJSON ocurren como parte de esa materializaci칩n.
- El overhead de Python es bajo, solo aparece marginalmente en `explode`, `group_by`, `sort` y `gc.collect`.
- El end to end del script (~0.60s) incluye overhead de arranque y el bloque de profiling.

### Polars MEMORY
- Tambi칠n est치 dominado por una sola llamada a `collect()` (0.251s de 0.256s).
- A diferencia de Q1, aqu칤 no hay m칰ltiples scans, por eso no existe el overhead t칤pico de streaming multi pass.
- El tiempo end to end (~0.63s) se mantiene en el mismo orden de magnitud que TIME.

**Insight principal**: en Q3, el enfoque MEMORY no introduce el costo extra de m칰ltiples lecturas del dataset. Por eso, TIME y MEMORY quedan pr치cticamente empatados.

---

## 3. Insights de Memoria (memray)

### Observaciones comunes
- Patr칩n de memoria estable: carga, procesamiento, liberaci칩n.
- La mayor parte del uso viene de buffers Arrow contiguos, reflejado en las mayores asignaciones ligadas a `collect()`.
- No se observan se침ales de fugas o crecimiento incremental.

### Comparaci칩n
- Peak RSS casi id칠ntico:
  - TIME: ~429 MB
  - MEMORY: ~427 MB
- La similitud es esperable en este dataset, porque el cuello de botella es materializar los buffers Arrow principales, y eso sucede en ambos enfoques.

Esto sugiere que, para datasets de este tama침o, la ventaja de MEMORY en Q3 no se manifiesta como ahorro inmediato de RAM, sino como opci칩n operacional cuando se necesite evitar mantener estructuras adicionales o adaptar la ejecuci칩n a restricciones externas.

---

## 4. Implicaciones de Escalabilidad

- A medida que el dataset crezca:
  - El uso de memoria en ambos enfoques crecer치 de forma aproximadamente lineal con el tama침o materializado, dominado por Arrow.
  - El tiempo deber칤a escalar favorablemente gracias al motor vectorizado y paralelo de Polars.
- Como TIME y MEMORY son equivalentes en este caso, la decisi칩n pr치ctica es operacional:
  - TIME cuando se quiere simplicidad y materializaci칩n directa.
  - MEMORY cuando se quiera mantener el patr칩n consistente de "usar TIME si cabe, si no cabe usar MEMORY" sin cambiar stack.

---

## 5. Decisi칩n Final para Q3

- Recomendaci칩n principal:  
  游녤 `q3_time.py` (Polars TIME)  
  Misma correctitud, mismo orden de magnitud en recursos, y es la referencia natural.

- Alternativa cuando la RAM es el factor limitante o se quiere mantener el patr칩n TIME vs MEMORY:  
  游녤 `q3_memory.py` (Polars MEMORY)  
  En Q3 el costo adicional es pr치cticamente nulo, por lo que es una alternativa segura.

En resumen:

> Usar siempre Polars.  
> En Q3, TIME y MEMORY son casi equivalentes.  
> Elegir TIME por defecto, y MEMORY cuando se requiera por restricciones de memoria o consistencia de estrategia.

Este profiling confirma que el motor (Rust + Arrow + lazy execution) domina el rendimiento, y que las decisiones est치n respaldadas por mediciones reales de tiempo y memoria.

