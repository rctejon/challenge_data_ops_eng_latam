# Q2: Top 10 emojis m치s usados

## Objetivo
Obtener los top 10 emojis m치s usados en tweets. Retornar el emoji y su conteo de ocurrencias.

## Enfoque

### Optimizaci칩n por tiempo (q2_time.py)

**Estrategia**: Carga completa en memoria usando Polars con procesamiento vectorizado.

**Caracter칤sticas**:
- Carga completa del dataset en memoria (scan_ndjson + collect)
- Extracci칩n vectorizada de emojis usando map_elements
- Operaciones de explode + group_by para conteo eficiente
- Garbage collection estrat칠gico para liberar memoria intermedia
- Trade-off: velocidad m치xima a costa de mayor uso de RAM

**Complejidad**:
- Tiempo: O(n) para procesamiento + O(k log k) para sort (k = emojis 칰nicos)
- Espacio: O(n) por DataFrame en memoria + O(m) por lista de emojis (m = total emojis)

#### Ejecuci칩n

**Prerequisitos**:
Asegurarse que el dataset existe en `data/raw/farmers-protest-tweets-2021-2-4.json`. Si no existe, descargar primero:
```bash
python src/dataset/download_dataset.py
```

**Comando de ejecuci칩n**:
```bash
python src/q2/q2_time_impl.py
```

**Salida esperada**:
- Muestra los top 10 emojis m치s usados con su conteo
- Ejecuta profiling de tiempo con cProfile
- Ejecuta profiling de memoria con memray (si est치 instalado)

**Archivos generados**:
- `q2_time_polars.prof` - Profiling de tiempo (cProfile)
- `q2_time_polars_mem.bin` - Profiling de memoria (memray)

#### An치lisis de profiling

**Analizar profiling de tiempo**:
```bash
python -m pstats q2_time_polars.prof
```

Comandos 칰tiles dentro de pstats:
```
stats 10        # Top 10 funciones por tiempo total
sort cumulative # Ordenar por tiempo acumulativo
sort time       # Ordenar por tiempo propio
```

**Analizar profiling de memoria**:
```bash
# Ver estad칤sticas generales
memray stats q2_time_polars_mem.bin
```

**Nota**: Si memray no est치 instalado, se puede instalar con:
```bash
pip install memray
```

### Optimizaci칩n por memoria (q2_memory.py)

**Estrategia**: Procesamiento por chunks con materializaci칩n m칤nima.

**Caracter칤sticas**:
- Procesamiento en chunks para minimizar carga en memoria
- Conteo incremental usando Counter
- Solo materializa resultados peque침os (top 10 emojis)
- Trade-off: menor consumo de memoria a costa de mayor tiempo de ejecuci칩n

**Complejidad**:
- Tiempo: O(n) para procesamiento secuencial por chunks
- Espacio: O(1) - solo almacena chunk actual + Counter de emojis 칰nicos

#### Ejecuci칩n

**Prerequisitos**:
Asegurarse que el dataset existe en `data/raw/farmers-protest-tweets-2021-2-4.json`. Si no existe, descargar primero:
```bash
python src/dataset/download_dataset.py
```

**Comando de ejecuci칩n**:
```bash
python src/q2/q2_memory_impl.py
```

**Salida esperada**:
- Muestra los top 10 emojis m치s usados con su conteo
- Ejecuta profiling de tiempo con cProfile
- Ejecuta profiling de memoria con memray (si est치 instalado)

**Archivos generados**:
- `q2_memory_polars.prof` - Profiling de tiempo (cProfile)
- `q2_memory_polars_mem.bin` - Profiling de memoria (memray)

#### An치lisis de profiling

**Analizar profiling de tiempo**:
```bash
python -m pstats q2_memory_polars.prof
```

Comandos 칰tiles dentro de pstats:
```
stats 10        # Top 10 funciones por tiempo total
sort cumulative # Ordenar por tiempo acumulativo
sort time       # Ordenar por tiempo propio
```

**Analizar profiling de memoria**:
```bash
# Ver estad칤sticas generales
memray stats q2_memory_polars_mem.bin
```

**Nota**: Si memray no est치 instalado, se puede instalar con:
```bash
pip install memray
```

---

## Resumen de Resultados y Conclusiones (TIME vs MEMORY)

<!-- TODO: Completar con resultados de profiling -->

Para Q2 se implementaron y perfilaron dos enfoques con **Polars**, optimizados respectivamente por **tiempo** y por **memoria**. Ambos producen resultados **id칠nticos y deterministas**, por lo que la comparaci칩n se centra en performance y consumo de recursos.

---

## 1. Resultados Clave

<!-- TODO: Completar tabla con resultados de benchmarking -->

| Enfoque | Tiempo ejecuci칩n | Peak RSS | Caracter칤stica dominante |
|-------|------------------|----------|-----------------------------|
| **Polars TIME** | TODO | TODO | Velocidad m치xima |
| **Polars MEMORY** | TODO | TODO | Menor materializaci칩n |

---

## 2. Insights de Performance

### Polars TIME

<!-- TODO: Completar con an치lisis de cProfile -->

### Polars MEMORY

<!-- TODO: Completar con an치lisis de cProfile -->

---

## 3. Insights de Memoria (memray)

### Observaciones comunes

<!-- TODO: Completar con an치lisis de memray -->

### Comparaci칩n

<!-- TODO: Completar con comparaci칩n de peak RSS y patrones de memoria -->

---

## 4. Implicaciones de Escalabilidad

<!-- TODO: Completar con proyecciones de escalabilidad -->

---

## 5. Decisi칩n Final para Q2

<!-- TODO: Completar con recomendaciones finales basadas en resultados -->

- **Recomendaci칩n principal**:
  游녤 `q2_time.py` (**Polars TIME**)
  Mejor balance global, m칤nima complejidad y m치xima velocidad.

- **Alternativa cuando la RAM es el factor limitante**:
  游녤 `q2_memory.py` (**Polars MEMORY**)
  Mayor tiempo de ejecuci칩n, pero menor consumo de memoria.

En resumen:

> **Usar siempre Polars**.
> TIME si el dataset cabe en memoria.
> MEMORY si no cabe.
